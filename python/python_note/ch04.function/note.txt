当编译器遇到def，会生成创建`函数对象`指令。而不仅仅是一个语法关键字。可以在任何地方动态创建函数对象。
一个完整的函数对象由函数和代码两部分组成。PyCodeObject包含了字节码等执行数据，PyFunctionObject则为其提供了状态信息。

typedef struct {
	PyObject_HEAD
	PyObject *func_code;					// PyCodeObject
	PyObject *func_globals;				// 所在模块的全局名字空间
	PyObject *func_defaults;			// 参数默认值列表
	PyObject *func_closure;				// 闭包列表
	PyObject *func_doc;						// __doc__
	PyObject *func_name;					// __name__
	PyObject *func_dict;					// __dict__
	pyObject *func_weakreflist;		// 弱引用链表
	PyObject *func_module;				// 所在Module
} PyFunctionObject;

4.1 创建

包括函数在内的所有对象都是第一类对象，可作为其他函数的实参或返回值。

- 在名字空间中，名字是唯一主键。因此函数在同一范围内不能“重载（overload）”
- 函数总是有返回值的。就算没有 return，默认也会返回 None。
- 支持递归调用，但不支持尾递归优化。最大深度 sys.getrecursionlimit()

```
def test(name):
	if name == "a":
		def a(): pass
		return a
	else:
		def b(): pass
		return b

print test("a").__name__
```

不同于用def定义复杂函数，lambda只能是有返回值的简单的表达式。使用赋值语句会引发语法错误，可以考虑用函数代替。

```
add = lambda x, y = 0: x + y
print add(1, 2)
print add(3)
print range(10)
print 0 and None or 0
print 1 and None or 1
print 0 and None or 2
print 1 and None or 3
print 0 and None or 4
print 1 and None or 5
print map(lambda x: x % 2 or x, range(10))
```

4.2 参数

可按位置顺序传参，也可不用关心顺序用命名实参。

```
def test(a, b):
	print a, b

test(1, "a")
test(b = "x",a = 100)
```

支持参数默认值。不过要小心，默认值对象在创建函数时生成，所有调用都使用同一对象。如果该默认值是可变类型，那么如同C静态局部变量。

```
def test(x, ints=[]):
	ints.append(x)
	return ints

print test(1)
print test(2)

print test(1, [])
print test(3)
```

默认参数后面不能有其他位置参数，除非是变参。

```
#def test(a, b=0, c): pass

def test(a, b=0, *args, **kwargs):
	print a, b
	print args
	print kwargs

test(1, 2, "a", "b", "c", x = 100, y = 200)
```

用 *args 收集 “多余” 的位置参数，**kwargs 收集“额外”的命名参数。这两个名字只是惯例，可自由命名。

lambda同样支持默认值和变参，使用方法完全一致。

4.3 作用域

函数形参和内部变量都存储在locals名字空间中。

除非使用global、nonlocal特别声明，否则在函数内部使用赋值语句，总是在locals名字空间中新建一个对象关联。注意：“赋值”是指名字指向新的对象，而非通过名字改变对象状态。

如果仅仅是引用外部变量，那么按 LEGB 顺序在不同作用域查找该名字

locals -> enclosing function -> globals -> __builtins__

- lcoals: 函数内部名字空间，包括局部变量和形参
- enclosing function: 外部嵌套函数的名字空间
- globals: 函数定义所在的模块的名字空间
- __buildins__: 内置模块的名字空间

通常内置模块 __builtin__ 在本地名字空间的名字是 __builtins__ 。但要记住这个说法一点也不靠谱，某些时候它又会莫名其妙地指向 __builtin__.__dict__。
如实在要操作该模块，建议显式 import __builtin__ 。

4.4 闭包

闭包是指：当函数离开创建环境后，依然持有其上下文状态。

为什么用function.func_closure，而不是堆栈帧的名字空间呢？因为 test 仅仅返回两个函数对象，
并没有调用它们，自然不可能为它们创建堆栈帧。这样就导致每次返回的a， b都是新创建的对象，
否则这个闭包状态就被覆盖了。
