# 第 5 章 迭代器

在 Python 文档中，实现接口通常被称为遵守协议。因为“弱类型”和“Duck Type”的缘故，很多静态语言中繁复的模式被消消抹平了。

## 5.1 迭代器

迭代器协议，仅需要 __iter__() 和 next() 两个方法。前者返回迭代器对象，后者依次返回数据，直到引发 StopIteration 异常结束。

最简单的做法是用内置函数 iter()，它返回常用类型的迭代器对象。问题是，序列数据已经可以被 for 处理，为何还要这么做？

```
>>> class Data(object):
...   def __init__(self):
...     self._data = []
...
...   def add(self, x):
...     self._data.append(x)
...
...   def data(self):
...     return iter(self._data)
...
>>> d = Data()
>>> d.add(1)
>>> d.add(2)
>>> d.add(3)
>>> for x in d.data(): print x
...
1
2
3
```

返回迭代器对象代替 self._data 列表，可避免对象状态被外部修改。或许你会尝试返回 tuple，但这需要复制整个列表，浪费更多的内存。

iter 很方便，但无法让迭代中途停止，这需要自己动手实现迭代器对象。在设计原则上，通常会将迭代器从数据对象中分离出去。因为迭代器需要维持状态，且可能有多个迭代器在同时操控数据，这些不该成为数据对象的负担，无端提升了复杂度。





















