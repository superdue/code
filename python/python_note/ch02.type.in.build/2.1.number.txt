2.1 数字

bool

None、0、空字符串、以及没有元素的容器对象都可视为 False，反之为 True。

>>> map(bool, [None, 0, "", u"", list(), tuple(), dict(), set(), frozenset()])
[False, False, False, False, False, False, False, False, False]
>>>

虽然有点古怪，但 True、False 的确可以当数字使用。

>>> int(True)
1
>>> int(False)
0
>>> range(10)[True]
1
>>> x = 5
>>> range(10)[x > 3]
1
>>>

int

在 64 位平台上，int 类型是 64 位整数（sys.maxint），这显然能应对绝大多数情况。整数是虚拟机特殊照顾对象：

- 从堆上按需申请名为 PyIntBlock 的缓存区域存储整数对象。
- 使用固定数组缓存 [-5, 257) 之间的小数字，只需计算下标就能获得指针。
- PyIntBlock 内存不会返还给操作系统，直至进程结束。

看看“小数字”和“大数字”的区别：

>>> a = 15
>>> b = 15
>>> a is b
True
>>> import sys
>>> sys.getrefcount(a)
13
>>> a = 257
>>> b = 257
>>> a is b
False
>>> sys.getrefcount(a)
2
>>>

因 PyIntBlock 内存只复用不回收，同时持有大量整数对象将导致内存暴涨，且不会在这些对象被回收后释放内存，造成事实上的内存泄露。

用 range 创建一个巨大的数字列表，这就需要足够多的 PyIntBlock 为数字对象提供存储空间。但换成 xrange 就不同了，每次迭代后，数字对象被回收，其占用内存空闲出来并被复用，内存也就不会暴涨了。

运行下面测试代码前，必须先安装 psutil 包，用来获取内存统计数据。

test1.py
test2.py

对比 range 和 xrange 所需的 RSS 值。

$ rvm:(ruby-2.1.1@rails4) python test1.py
49999995000000
pmem(rss=99131392L, vms=2609471488L)

$ rvm:(ruby-2.1.1@rails4) python test2.py
49999995000000
pmem(rss=7102464L, vms=2526310400L)

在实际开发中，很少会遇到这样的情形。就算是海量整数去重、排序，我们也可用位图等算法来节约内存使用。Python 3 已经用 xrange 替换掉了默认的 range，我们使用 2.x 时稍微注意一下即可。

long

当超出 int 限制时，会自动转换成 long。作为变长对象，只要内存足够，足以存储无法想像的天文数字。

>>> import sys
>>> a = sys.maxint
>>> type(a)
<type 'int'>
>>> b = a + 1
>>> type(b)
<type 'long'>
>>> 1 << 3000
1230231922161117176931558813276752514640713895736833715766118029160058800614672948775360067838593459582429649254051804908512884180898236823585082482065348331234959350355845017413023320111360666922624728239756880416434478315693675013413090757208690376793296658810662941824493488451726505303712916005346747908623702673480919353936813105736620402352744776903840477883651100322409301983488363802930540482487909763484098253940728685132044408863734754271212592471778643949486688511721051561970432780747454823776808464180697103083861812184348565522740195796682622205511845512080552010310050255801589349645928001133745474220715013683413907542779063759833876101354235184245096670042160720629411581502371248008430447184842098610320580417992206662247328722122088513643683907670360209162653670641130936997002170500675501374723998766005827579300723253474890612250135171889174899079911291512399773872178519018229989376L
>>> sys.getsizeof(1 << 0xFFFFFFFF)
572662332
>>>

使用 long 的机会不多，Python 也就没有必要专门为其设计优化策略。

float

使用比精度浮点数（float），不能“精确”表示某些十进制的小数值。尤其是“四舍五入（round）”的结果，可能和预想不同。

>>> 3 / 2
1
>>> float(3) / 2
1.5
>>> 3 * 0.1 == 0.3
False
>>> round(2.675, 2)
2.67
>>>

如果需要，可用 Decimal 代替，它能精确控制运算精度、有效数位和 round 的结果。

>>> from decimal import Decimal, ROUND_UP, ROUND_DOWN
>>> float('0.1') * 3 == float('0.3')
False
>>> Decimal('0.1') * 3 == Decimal('0.3')
True
>>> Decimal('2.675').quantize(Decimal('.01'), ROUND_UP)
Decimal('2.68')
>>> Decimal('2.675').quantize(Decimal('.01'), ROUND_DOWN)
Decimal('2.67')
>>>

在内存管理上，float 也采用 PyFloatBlock 模式，但没有特殊的“小浮点数”。