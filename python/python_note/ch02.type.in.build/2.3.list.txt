2.3 列表

从功能上看，列表（list）类似 Vector，而非数组或链表。

- 列表对象和存储元素指针的数组是分开的两块内存，后者在堆上分配。
- 虚拟机会保留 80 个列表复用对象，但其元素指针数组会被释放。
- 列表会动态调整指针数组大小，预分配内存多于实际元素数量。

创建列表：

>>> []
[]
>>> ['a','b'] * 3
['a', 'b', 'a', 'b', 'a', 'b']
>>> ['a','b'] + ['c','d']
['a', 'b', 'c', 'd']
>>> list("abcd")
['a', 'b', 'c', 'd']
>>> [x for x in range(3)]
[0, 1, 2]
>>>

常见操作：

>>> l = list("abc")
>>> l[1] = 2
>>> l
['a', 2, 'c']
>>> l = list(xrange(10))
>>> l[2:-2]
[2, 3, 4, 5, 6, 7]
>>> l = list("abcabc")
>>> l.count("b")
2
>>> l = list("abcabc")
>>> l.index("a", 2)
3
>>> l = list("abc")
>>> l.append("d")
>>> l
['a', 'b', 'c', 'd']
>>> l = list("abc")
>>> l.insert(1, 100)
>>> l
['a', 100, 'b', 'c']
>>> l = list("abc")
>>> l.extend(range(3))
>>> l
['a', 'b', 'c', 0, 1, 2]
>>> l = list("abcabc")
>>> l.remove("b")
>>> l
['a', 'c', 'a', 'b', 'c']
>>> l = list("abc")
>>> l.pop(1)
'b'
>>> l
['a', 'c']
>>>

可用 bisect 向有序列表中插入元素。

>>> import bisect
>>> l = ["a","d","c","e"]
>>> l.sort()
>>> l
['a', 'c', 'd', 'e']
>>> bisect.insort(l, "b")
>>> l
['a', 'b', 'c', 'd', 'e']
>>> bisect.insort(l, "d")
>>> l
['a', 'b', 'c', 'd', 'd', 'e']
>>>

性能

列表用 realloc() 调整指针数组内存大小，可能需要复制数据。插入和删除操作，还会循环移动后续元素。这些都是潜在的性能隐患。对于频繁增删元素的大型列表，应该考虑用链表等数据结构代替。

下面的例子测试了两种创建列表对象方式的性能差异。为获得更好测试结果，我们关掉了 GC，元素使用同一个小整数对象，减少其他干扰因素。

TODO

从测试结果来看，性能差异非常大。

某些时候，可以考虑用数组代替列表。和列表存储对象指针不同，数组直接内嵌数据，既省了创建对象的内存开销，又提升了读写效率。

>>> import array
>>> a = array.array("l", range(10))
>>> a
array('l', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a.tolist()
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a = array.array("c")
>>> a.fromstring("abc")
>>> a
array('c', 'abc')
>>> a.fromlist(list("def"))
>>> a
array('c', 'abcdef')
>>> a.extend(array.array("c", "xyz"))
>>> a
array('c', 'abcdefxyz')
>>>