# 第 6 章 模块

不同于 C++, Java, C# namespace 仅作为符号隔离前缀, Python 模块是运行期对象. 模块对
应同名源码文件,为成员提供全局名字空间.

## 6.1 模块对象

模块对象有几个重要属性:

  - `__name__`: 模块名 `<package>.<module>`, 在 sys.modules 中以此为主键.
  - `__file__`: 模块完整文件名.
  - `__dict__`: 模块 globals 名字空间

除使用 py 文件外,还可动态创建模块对象.

demo1.py

为模块动态添加函数成员时,需注意函数所引用的是其定义模块的名字空间.

demo1.py

imp.new_module() 也可用来动态创建模块对象,同样不会添加到 sys.modules.

demo2.py

**reload**

当模块源文件发生变更时,可使用内置函数 reload() 重新导入模块.新建模块对象依旧使用原内存
地址,只是原先被引用的内部成员对象不会被同步刷新.

测试一下,为避免本地名字引用造成干扰,我们直接从 sys.modules 获取模块.

**有点问题**

## 6.2 搜索路径

虚拟机按以下顺序搜索模块(包):

  - 当前进程根目录.
  - PYTHONPATH 环境变量指定的路径列表
  - Python 标准库目录列表
  - 路径文件(pth)保存的目录(通常放在site-packages目录下)

进程启动后,所有这些路径都被组织到 sys.path 列表中(顺序`可能`会被修改).任何 import 操作都
按照 sys.path 列表查找目标目标模块. 当然,可以用代码往 sys.path 添加自定义路径.

虚拟机按以下顺序匹配目标模块:

  - py 源码文件
  - pyc 字节码文件
  - egg 包文件或目录
  - so, dll, pyd 等扩展文件
  - 内置模块
  - 其他

要执行程序,源文件不是必须的.实际上,很多软件发布时都会删掉py文件,仅保留二进制pyc字节码文件.
但要注意,字节码很容易被反编译,不能奢求它能带来安全.

**find_module**

可用 imp.find_module() 获取模块的具体文件信息

## 6.3 导入模块

进程中的模块对象通常是唯一的.在首次成功导入后,模块对象被添加到 sys.modules ,以后导入
操作总是先检查模块对象是否已经存在.可用 `sys.modules[__name__]`获取当前模块对象

关键字 import 将包,模块或成员对象导入到当前名字空间中,可以是globals,也可以是函数内部的 locals
名字空间.

如果待导入对象和当前名字空间已有名字冲突,可用 as 更换别名. 需要注意, "import *" 不会
导入模块私有成员(以下划线开头的名字)和 `__all__` 列表中未指定的对象.

在函数中使用 "import *" 会引发警告,虽然不影响是使用,但应该避免引入用不到的名字.(Python3 已经禁止该用法了)

**`__all__`**

因为 import 实际导入的是目标模块 globals 名字空间中的成员,那么就有一个问题:目标模块也会导入其他模块,
这些模块同样在目标模块的名字空间中. "import *"操作时,所有这些一并被带入到当前模块中,造成一定程度的污染.
建议在模块中用 __all__ 指定可被批量导出的成员名单.

`__all__ = ["add", "x"]`

私有成员和 `__all__` 都不会影响显式导出目标模块成员. Python并没有严格的私有权限控制,仅以特定的命名规则来提醒调用人员.

**`__import__`**

和 import 关键字不同,内置函数 `__import__()` 以字符串为参数导入模块. 导入的模块会被添加到 sys.modules, 但不会在当前名字空间中创建引用.

用 `__import__` 导入 package.module 时,返回的是 package 而非 module.

只有 fromlist 参数不会空时,才会返回目标模块.

`__import__` 太麻烦,建议用 importlib.import_module() 代替.

注意:关键字 import 总是优先查找当前模块所在目录,而 `__import__`,`import_module`则是优先查找
进程根目录. 所以用 `__import__` ,`import_module` 导入包模块时,必须带上包前缀.

**load_source**

imp 另提供了 load_source(), load_compiled() 等几个函数,可用来载入不在 sys.path 搜索路径列表
中的模块文件.优先使用已编译的字节码文件,模块对象会被添加到 sys.modules

需要小心,这些函数类似 reload(), 每次都会新建模块对象.

## 6.4 构建包

将多个模块文件放到独立目录,并提供初始化文件 `__init__.py`,就形成了包(package)

无论是导入包,还是导入包中任何模块或成员，都会执行初始化文件,且仅执行一次.可用来初始化包环境,存储帮助,版本等信息.

**`__all__`**

`from <package> import *` 仅导入 `__init__.py` 的名字空间,而该文件通常又只是个空文件,这意味着没有任何模块被导入.
此时就需要用 `__all__` 指定可以被导入的模块名字列表,该定义无需将模块显式引入到 `__init__.py` 名字空间.

有太多理由不建议使用 `import *`,比如引入不需要的模块,意外 "覆盖" 当前空间同名对象等等.

换种做法,将要公开的模块和模块成员显式导入到 `__init__.py` 名字空间中,调用者只需 `import <package>`,然后用 `<package>.<member>`
就可访问所需的目标对象. 如此可规避上述问题,还有助于隐藏包的实现细节,减少外部对包文件组织结构的依赖.

**`__path__`**

某些时候,包内的文件太多,需要分类存放到多个目录中,但又不想拆分成新的包或子包.这么做是允许的,只要在 `__init__.py` 中用 `__path__` 指定所有子目录
的全路径即可(子目录可放在包外)

稍微改进一下,还可以用 os.listdir() 扫描全部子目录,自动形成路径列表

**pkgutil**

如果要获取包里面的所有模块列表,不应该用 os.listdir(),而是 pkgutil 模块.

**egg**

将包压缩成单个文件,以便于分发和安装.类似Java JAR那样.



