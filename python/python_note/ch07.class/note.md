# 第7章 类

由于历史原因,Python2.x同时存在两种类模型,算是一个不大不小的坑.面向对象思想的演变也在影响着语言的进化,单根继承在 Python 中对应的是 New-Style Class, 而非 Classic Class.

Python3终于甩掉包袱,仅保留New-Style Class. 所以呢,就算还在用2.x开发,也别再折腾Classic Class,踏踏实实从object继承,或在源文件设置默认元类.

demo1.py

## 7.1 名字空间

类型是类型,实例是实例.如同ref,关键字class的作用是创建类型对象.前面章节也曾提到过,类型对象很特殊,在整个进程中是单例的,是不被回收的.

因为New-Style Class, Class和Type总算是一回事了.

demo2.py

类型(class)存储了所有静态字段和方法(包括实例方法),而实例(instance)仅存储实例字段,从基类object开始,所有继承层次上的实例字段.官方文档将所有成员统称为Attribute.

类型和实例各自拥有自己的名字空间

访问对象成员时,就从这几个名字空间中查找,而非以往的 globals, locals

`成员查找顺序: instance.__dict__ -> class.__dict__ -> baseclass.__dict__`

注意分清对象成员和普通名字的差别.就算在对象方法中,普通名字依然遵循LEGB规则.

L: 局部
E: 局部闭包函数
G: 全局
B: 内置

## 7.2 字段

字段(field)和属性(Property)是不同的.

  - 实例字段存储在 `instance.__dict__`, 代表单个对象实体的状态
  - 静态字段存储在 `class.__dict__`, 为所有同类型实例共享
  - 必须通过类型和实例对象才能访问字段
  - 以双下划线开头的class和instance成员视为私有,会被重命名.(module成员不变)

可以在任何时候添加实例字段,仅影响该实例名字空间,与其他同类型实例无关.

要访问静态字段,除了`class.<name>`外,也可以用`instance.<name>` 按照成员查找规则,只要没有同名的实例成员,那么就继续查找`class.__dict__`

demo3.py

面向对象一个很重要的特征就是封装,它隐藏对象内部实现细节,仅暴露用户所需的接口.因此私有字段是极其重要的,可避免非正常逻辑修改.

私有字段以爽下划线开头,无论是静态还是实例成员,都会被重命名:`_<class>__<name>`

demo4.py

某些时候,我们既想使用私有字段,又不想放弃外部访问权限.

  - 用重命名后的格式访问
  - 只用一个下划线,仅提醒,不重命名

不必过于纠结"权限"这个词,从底层来看,本就没有私有一说.

## 7.3 属性

属性(Property)是由getter,setter,deleter几个方法构成的逻辑.属性可能直接返回字段值,也可能是动态逻辑运算的结果.

属性以装饰器或描述符实现,原理以后再说.实现规则很简单,也很好理解.

demo5.py

从`class.__dict__`可以看出,几个属性方法最终变成了`property object`这也解释了几个同名方法为何没有引发错误.既然如此,我们可以直接用`property()`实现属性

demo6.py

区别不大,只是`class.__dict__`中保留了几个方法

属性方法多半都很简单,用lambda实现会更加简洁.鉴于lambda函数不能使用赋值语句,故改用setter.还得注意别用会被重命名的私有字段名做参数

不用于前面提过的对象成员查找规则,属性总是比同名实例字段优先.

demo7.py

尽可能使用属性,而不是直接暴露内部字段.

## 7.4 方法

实例方法和函数的最大区别是self这个隐式参数

demo8.py

从上面的代码可以看出实例方法的特殊性.当用实例调用时,它是个bound method,动态绑定到对象实例.而当用类型调用时,是unbound method,必须显式传递self参数.

那么静态方法呢?为什么必须用staticmethod,classmethod装饰器?

demo9.py

不实用装饰器a,将被当作了实例方法,自然不能以静态方法调用.
装饰器classmethod绑定了类型对象作为隐式参数.

除了上面说的这些特点外,方法的使用和普通函数类似,可以有默认值,变参.实例方法隐式参数self只是习惯性命名,可以用你喜欢的任何名字.

说到对象,总会有几个特殊的可选方法:

  - `__new__`: 创建对象实例
  - `__init__`: 初始化对象状态
  - `__del__`: 对象回收前被调用

demo10.py

构造方法`__new__`可返回任意类型,但不同的类型会导致`__init__`方法不被调用

在方法里访问对象成员时,必须使用对象实例引用.否则会当作普通名字,依照LEGB规则查找.

因为所有的方法都存储在`class.__dict__`,不可能出现同名主键,所以不支持方法重载(overload)

## 7.5 继承

除了所有基类的实例字段都存储在`instance.__dict__`外,其他成员依然是各归各家.

demo11.py

如果派生类不提供初始化方法,则默认会查找并使用基类的方法.

基类引用存储在`__base__`,直接派生存储在`__subclasses__`

demo11.py

可以用`issubclass()`判断是否继承自某个类型,或用`isinstance()`判断实例对象的基类.

demo11.py

成员查找规则允许我们用实例引用基类所有成员,包括实例方法,静态方法,静态字段.但这里有个坑:
如果派生类有一个与基类实例方法同名的静态成员,那么首先被找到的是该静态成员,而不是基类的实例方法了.
因为派生类的名字空间优先于基类.

demo12.py

同样因为优先级的缘故,只需在派生类创建一个同名实例方法,就可实现"覆盖(override)",签名可完全不同.

**多重继承**

Python诞生的时候,单继承还不是主流思想.至于多重继承好不好,估计要打很久的口水仗.

多重继承成员搜索顺序,也就是mro(method resolution order)要稍微复杂一点.归纳一下就是:
从下到上(深度优先,从派生类到基类),从左到右(基类声明顺序). mro和我们前面提及的成员查找规则是有区别的,
`__mro__`列表中并没有instance. 所以在这里表述时,需要注意区别.

**super**

`super()`起到其他语言base关键字的作用,它依照mro顺序搜索基类成员.

super的类型参数决定了mro列表中的搜索起始位置,总是返回该参数后续类型的成员.单继承时总是搜索该参数的基类型.

不建议用`self.__class__`代替当前类型名,因为这可能会引发混乱

demo13.py

在多重继承初始化方法中使用super可能会引发一些奇怪的状况.

demo14.py

多重继承将很多问题复杂化,建议该用组合模式实现类似的功能.

**`__bases__`**

类型对象有两个相似的成员:

  - `__base__`: 只读, 总是返回`__bases__[0]`
  - `__bases__`: 基类列表, 可直接修改来更换基类,影响mro顺序.

对多继承一样有效,比如调整基类顺序.

通过更换基类,我们可实现代码注入(Code Inject),影响既有类型的行为.事实上,我们还可以更改实例的类型

**抽象类**

抽象类(Abstract Class)无法实例化,且派生类必须"完整"实现所有抽象成员才可创建实例.

如果派生类也是抽象类型,那么可以部分实现或完全不实现基类抽象成员.

派生类Manager也是抽象类,它实现了部分基类的抽象成员,又增加了新的抽象成员.这种做法
在面向对象模式里很常见,只需保证整个继承体系走下来,所有层次的抽象成员都被实现即可.

## 7.6 开放类

OpenClass几乎是搜有动态语言的标配,也是精华所在.即便是在运行期,我们也可以随意改动对象,增加或删除成员.

增加成员时,要明确知道放到哪儿,比如将实例方法放到`instance.__dict__`是没有效果的.

因为不是bound method,所以必须显式传递对象引用.正确的做法是放到`class.__dict__`

静态方法必须用装饰器staticmethod, classmethod包装一下,否则会被当作实例方法.

在运行期调整对象成员，时常要用到几个以字符串为参数的内置函数.其中hasattr, getattr依照成员查找规则搜索对象成员.而setattr,delattr则直接操作实例和类型的名字空间.

demo15.py

**`__slots__`**

`__slots__`属性会阻止虚拟机创建实例`__dict__`,仅为名单中的指定成员分配内存空间.这有助于减少内存占用,提升执行性能,尤其在需要大量此类对象的时候.

虽然没有了`__dict__`,但依然可以用dir()和inspect.getmember()获取实例成员信息

其派生类同样必须用`__slots__`为新增字段分配存储空间(即便是空 `__slots__=[]`),否则依然会创建`__dict__`,反而导致更慢的执行效率.

如果需要创建"海量"对象实例,优先考虑"__slots__"将节约大量内存.

## 7.7 操作符重载

**`__setitem__`**
又称索引器,像序列或字典类型那样操作对象

**`__call__`**
像函数那样调用对象,也就是创说中的callable

**`__dir__`**
配合`__slots__`隐藏内部成员

**`__getattr__`**

先看看这几个方法的触发时机

  - `__getattr__`: 访问不存在的成员
  - `__setattr__`: 对任何成员的赋值操作
  - `__delattr__`: 删除成员操作
  - `__getattribute__`: 访问任何存在或不存在的成员,包括`__dict__`

不要在这几个方法里直接访问对象成员,也不用hasattr/getattr/setattr/delattr 函数,因为他们
会被再次拦截,形成无线循环.正确的做法是直接操作`__dict__`

而`__getattribute__`连`__dict__`都会拦截,只能用基类的`__getattribute__`返回结果

**`__cmp__`**

`__cmp__`通过返回数字来判断大小,而`__eq__`仅用于相等判断.

**提示:**

面向对象理论很复杂,涉及到的内容十分繁复,应该找本经典的大部头好好啃啃.
