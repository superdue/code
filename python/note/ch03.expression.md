# 第3章 表达式

3.1 句法规则

Python源码格式有点特殊。首先，可能因为出生所代久远的缘故，编译器默认编码采用ASCII，而非当通行的UTF-8。其次，就是强制缩进格式让很多人“纠结”， 甚至“望而却步”。

源文件编码

下面这样的错误，初学时很常见。究其原因，还是默认将文件当成ASCII码的缘故。

。。。

解决方法：在文件头部添加正确的编码标识。

```
#!/usr/bin/env python
# coding=utf-8
``

也可以写成

```
# -*- encoding:utf-8 -*-
```

强制缩进

缩进是强制性的语法规则。通常建议用4个空格代替TAB，好在多数编辑器都能自动转换。

最大的麻烦就是从网页拷贝代码时，缩进丢失导致源码成了乱码。解决方法是：

* 像很多C程序员那样，在block尾部添加 "# end" 注释。
* 如果嫌不好看，可自定义一个 end 伪关键字。

```
#!/usr/bin/env python
# coding=utf-8

__builtins__.end = None

def test(x):
    if x > 0:
        print "a"
    else:
        print "b"
    end
end

def main():
    print "世界末日！"
end

if __name__ == "__main__":
    main()
```

只要找到 end，就能确定 code block 的缩进范围了。

注释

注释从 # 开始，到行尾结束，不支持跨行大段的描述可以用 """__doc__"""。

语句

可以用 ";" 将多条语句写在同一行，或者用 "\" 将一条语句拆分成多行。

```
>>> d = {}; d["a"] = 1; d.items()
[('a', 1)]
>>> for k,v in \
        d.items():
	print k,v

	
a 1
```

某些 ()、[]、{} 表达式无需 "\" 就可写成多行。

```
>>> d = {
	"a": 1,
	"b": 2
	}
>>> d.pop("a",
      2)
1
```

帮助

可以非常方便地为函数、模块和类添加帮助信息。

```
>>> def test():
	"""
func help
"""
	pass

>>> test.__doc__
'\nfunc help\n'
>>> class User(object):
	"""User Model"""
	def __init__(self):
		"""user.__init__"""
		pass

	
>>> User.__doc__
'User Model'
>>> User.__init__.__doc__
'user.__init__'
```

在shell用help()查看帮助信息，它会合并对象所有成员的帮助内容。

3.2 命名规则

命名规则不算复杂，只不过涉及私有成员命名时有点讲究。

* 必须以字母或下划线开头，且只能是下划线、字母和数字的组合。
* 不能和语言保留字相同。
* 名字区分大小写。
* 模块中下划线开头的名字视为私有。
* 以双下划线开头的类成员名字视为私有。
* 同时以双下划线开头和结尾的名字，通常是特殊成员。
* 单一下划线代表是最后表达式的返回值。

```
>>> s = set("abc")
>>> s.pop()
'a'
>>> _
'a'
```

保留字（包括Python 3）：

...

3.3 赋值

除非在函数中使用关键字 global、nonlocal 指明外部名字，否则 赋值语句总是在当前名字空间创建或修改 {name:object} 关联。

与C以block为隔离，能在函数中创建多个同名变量不同，Python 函数所有代码共享同一名字空间，会出现下面这样的状况。

```
>>> def test():
	while True:
		x = 10
		break
	print locals()
	print x

	
>>> test()
{'x': 10}
10
```

支持用序列类型或迭代器对多个名字同时赋值。

```
>>> a, b = "a", "b"
>>> a, b
('a', 'b')
>>> a, b = "ab"
>>> a, b
('a', 'b')
>>> a, b = [1, 2]
>>> a, b
(1, 2)
>>> a, b = xrange(2)
>>> a, b
(0, 1)
>>> a, b = xrange(3)

Traceback (most recent call last):
  File "<pyshell#373>", line 1, in <module>
    a, b = xrange(3)
ValueError: too many values to unpack
>>> a,b = xrange(1)

Traceback (most recent call last):
  File "<pyshell#374>", line 1, in <module>
    a,b = xrange(1)
ValueError: need more than 1 value to unpack
```

一旦值多过名字数量，会引发异常。要么切片，要么用“_”补位。

```
>>> a, b = "abc"

Traceback (most recent call last):
  File "<pyshell#375>", line 1, in <module>
    a, b = "abc"
ValueError: too many values to unpack
>>> a, b, _ = "abc"
>>> a, b = "abc"[:2]
```

Python 3 对此提供了更好的支持。

```
>>> a, *b, c = "a1234c"
>>> a, b, c
('a', ['1','2','3','4'], 'c')
```

3.4 表达式

if

只需记住将"else if"换成"elif" 即可。

```
>>> x = 10
>>> if x > 0:
	print "+"
elif x < 0:
	print "-"
else:
	print "0"

	
+
```

可以改造得简单一些。

```
>>> x = 1
>>> print "+" if x > 0 else ("-" if x < 0 else "0")
+
>>> x = 0
>>> print "+" if x > 0 else ("-" if x < 0 else "0")
0
>>> x = -1
>>> print "+" if x > 0 else ("-" if x < 0 else "0")
```

或者利用and、or条件短路，写得更简洁些。

```
>>> x = 1
>>> print (x > 0 and "+") or (x < 0 and "-") or "0"
+
>>> x = 0
>>> print (x > 0 and "+") or (x < 0 and "-") or "0"
0
>>> x = -1
>>> print (x > 0 and "+") or (x < 0 and "-") or "0"
```

可以将两次比较合并成一个表达式。

```
>>> x = 10
>>> if (5 < x <= 10): print "haha!"

haha!
```

条件表达式不能包含赋值语句，习惯此写法的需要调整一下了。

```
>>> if (x = 1) > 0: pass
SyntaxError: invalid syntax
```

while

比我们熟悉的while多了个可选的else分支。如果循环没有被中断，那么else就会执行。

```
>>> x = 3
>>> while x > 0:
	x -= 1
else:
	print "over!"

	
over!
>>> while True:
	x += 1
	if x > 3: break
else:
	print "over!"

		
```

利用else分支标记循环逻辑被完整处理是个不错的主意。

for

更名为 foreach 可能更合适一些，用来循环处理序列和迭代器对象。
