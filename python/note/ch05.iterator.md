# 第5章 迭代器

在 Python 文档中，实现接口通常被称为遵守协议。因为“弱类型”和“Ducy Type”的缘故，很多静态语言中繁复的模式被消消抹平了。

5.1 迭代器

迭代器协议，仅需要 __iter__() 和 next() 两个方法。前者返回迭代器对象，后者依次返回数据，直到引发StopIteration异常线束。

最简单的做法是用内置函数 iter()，它返回常用类型的迭代器包装对象。问题是，序列类型已经可以被 for 处理，为何还要这么做？

```
>>> class Data(object):
	def __init__(self):
		self._data = []
	def add(self, x):
		self._data.append(x)
	def data(self):
		return iter(self._data)

	
>>> d = Data()
>>> d.add(1)
>>> d.add(2)
>>> d.add(3)
>>> for x in d.data(): print x

1
2
3
```

返回迭代器对象代替self._data列表，可避免对象状态被外部修改。或许你会尝试返回 tuple，但这需要复制整个列表，浪费更多的内存。

iter()很方便，但夫法让迭代中途停止，这需要自己动手实现迭代器对象。在设计原则上，通常会将迭代器从数据对象中分离出去。因为迭代器需要维持状态，且可能有多个迭代器在同时操控数据，这些不该成为数据对象的负担，无端提升了复杂度。

```
>>> class Data(object):
	def __init__(self, *args):
		self._data = list(args)
	def __iter__(self):
		return DataIter(self)

	
>>> class DataIter(object):
	def __init__(self, data):
		self._index = 0
		self._data = data._data
	def next(self):
		if self._index >= len(self._data): raise StopIteration()
		d = self._data[self._index]
		self._index += 1
		return d

	
>>> d = Data(1, 2, 3)
>>> for x in d: print x

1
2
3
```

Data仅仅是数据容器，只需 __iter__ 返回迭代器对象，而由DataIter提供next方法。

除了 for 循环，迭代器也可以直接用 next() 操控。

```
>>> d = Data(1, 2, 3)
>>> it = iter(d)
>>> it
<__main__.DataIter object at 0x029869B0>
>>> next(it)
1
>>> next(it)
2
>>> next(it)
3
>>> next(it)

Traceback (most recent call last):
  File "<pyshell#173>", line 1, in <module>
    next(it)
  File "<pyshell#163>", line 6, in next
    if self._index >= len(self._data): raise StopIteration()
StopIteration
```

5.2 生成器

基于索引实现的迭代器有些丑陋，更合理的做法是用 yield 返回实现了迭代器协议的 Generator 对象。

```
>>> class Data(object):
	def __init__(self, *args):
		self._data = list(args)
	def __iter__(self):
		for x in self._data:
			yield x

			
>>> d = Data(1, 2, 3)
>>> for x in d: print x

1
2
3
```

编译器魔法会将包含 yield 的方法（或函数）重新打包，使其返回 Generator 对象。这样一来，就无须废力气维护额外的迭代器类型了。

```
>>> d.__iter__()
<generator object __iter__ at 0x02974198>
>>> iter(d).next()
1
```

协程

yield 为何能实现这样的魔法？这涉及到协程（coroutine）的工作原理。先看下面的例子。

```
>>> def coroutine():
	print "coroutine start..."
	result = None
	while True:
		s = yield result
		result = s.split(",")

		
>>> c = coroutine()
>>> c.send(None)
coroutine start...
>>> c.send("a,b")
['a', 'b']
>>> c.send("c,d")
['c', 'd']
>>> c.close()
>>> c.send("e,f")

Traceback (most recent call last):
  File "<pyshell#199>", line 1, in <module>
    c.send("e,f")
StopIteration
```

协程执行流程：
* 创建协程后对象，必须使用send(None)或next()启动。
（问题一： 应该是“创建协程对象后”吧？）
* 协程在执行 yield result 后让出执行绪，等待消息。
* 调用方发送 send("a,b")消息。协程恢复执行，将接收到的数据保存到 s，执行后续流程。
* 再次循环到 yield，协程返回前面的处理结果，并再次让出执行绪。
* 直到关闭或被引发异常。

close() 引发协程 GeneratorExit 异常，使其正常退出。而 throws() 可以引发任何类型的异常，这个需要在协程内部捕获。

虽然生成器 yield 能轻松实现协程机制，但离真正意义上的高并发还有不小的距离。可以考虑使用成熟的第三方库，比如 gevent/eventlet，或直接用greenlet。

5.3 模式

善用迭代器，总会有意外的惊喜。

生产消费模型

利用 yield 协程特性，我们无需多线程就可以编写生产消费模型。

```
>>> def consumer():
	while True:
		d = yield
		if not d: break
		print "consumer:", d

		
>>> c = consumer()
>>> c.send(None)
>>> c.send(1)
consumer: 1
>>> c.send(2)
consumer: 2
>>> c.send(3)
consumer: 3
>>> c.send(None)

Traceback (most recent call last):
  File "<pyshell#224>", line 1, in <module>
    c.send(None)
StopIteration
```

改进回调

回调函数是实现异步操作的常用方法，只不过代码规模一大，看上去就不那么舒服了。好好的逻辑被切分到两个函数里，维护也是个问题。有了yield，完全呆以用blocking style 编写怪异步调用。

下面是callback版本的示例，其中Framework调用logic，在完成某些操作或者接收到信号后，用callback返回异步结果。

```
>>> def framework(logic, callback):
	s = logic()
	print "[FX] logic:", s
	print "[FX] do something..."
	callback("async:" + s)

	
>>> def logic():
	s = "mylogic"
	return s

>>> def callback(s):
	print s

	
>>> framework(logic, callback)
[FX] logic: mylogic
[FX] do something...
async:mylogic
```

看看用yield改进的blocking style版本。

```
>>> framework(logic, callback)
[FX] logic: mylogic
[FX] do something...
async:mylogic
>>> def framework(logic):
	try:
		it = logic()
		s = next(it)
		print "[FX} logic:", s
		print "[FX] do something"
		it.send("async:" + s)
	except StopIteration:
		pass

	
>>> def logic():
	s = "mylogic"
	r = yield s
	print r

	
>>> framework(logic)
[FX} logic: mylogic
[FX] do something
async:mylogic
```

尽管framework变得复杂了一些，但却保持了logic的完整性。blocking style样式的编码给逻辑维护带来的好处无需言说。

